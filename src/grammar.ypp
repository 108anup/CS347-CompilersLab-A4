%locations

%code requires {
	#include "errors.h"
	#include "location.h"
	#include "lexer.h"
	#include "ast.h"
	#include <vector>
  #include <map>

	using namespace std;
}

%{
  #include <stdio.h>

  extern int yylex();
  extern int yyerror(char *);
%}

%union{
  char *name;
  enum Type type;
  
  Declaration *decl;
  FuncDecl *funcDecl;
  Identifier *varDecl;
  vector<IntConst *> *dimList;

  StatementBlock *stmtBlock;
  vector<Statement *> *stmtList;
  map<string, Identifier *> *varDecls;
  
  Statement *stmt;
	ExprStatement *exprStmt;
	SelStatement *selStmt;
	IterStatement *iterStmt;

	Expression *expr;
	OpExpression *opExpr;
	Operator *op;
	Access *access;

  int intConst_t;
	bool boolConst_t;
	char *stringConst_t;
	double doubleConst_t;

	IntConst *intConst;
  BoolConst *boolConst;
  StringConst *stringConst;
  DoubleConst *doubleConst;
}

%token ELSE FOR IF RETURN WHILE PTR_OP INC_OP DEC_OP AND_OP OR_OP LT GT LE_OP GE_OP EQ_OP NE_OP DO
%token NOT AMP TILDE STAR ASSIGN OPEN_BRACKET CLOSED_BRACKET OPEN_CURLY CLOSED_CURLY OPEN_SQUARE CLOSED_SQUARE
%token SEMI COMMA DOT PLUS MINUS DIVIDE MODULUS PIPE XOR QUES COLON
%token <name> ID
%token <type> BOOL CHAR INT FLOAT VOID
%token <intConst_t> NUM
%token <doubleConst_t> REAL
%token <stringConst_t> STRING_LITERAL
%token <boolConst_t> BOOLEAN

%nonassoc "UIF"
%nonassoc ELSE

%left OR_OP
%left AND_OP
%left EQ_OP NE_OP
%left GT
%left LT
%left PLUS MINUS
%left STAR DIVIDE
%right NOT
%right UPLUS UMINUS
%right INC_OP DEC_OP

%type <decl> declaration
%type <varDecl> variable_declaration
%type <type> type_specifier
%type <dimList> bracket_list

%type <funcDecl> function_declaration
%type <varDecls> parameter_list
%type <varDecls> variable_declarations
%type <stmtBlock> statement_block
%type <stmtList> statement_list
%type <stmt> statement
%type <exprStmt> expression_statement
%type <selStmt> selection_statement
%type <iterStmt> iteration_statement

%type <expr> primary_expression unary_expression binary_arith_expression conditional_expression assignment_expression
%type <op> unary_operator binary_operator conditional_operator

%%

declaration_list
: declaration_list declaration {(*global_sym_table)[$2->name] = $2;}
| /* EPSILON */ {global_sym_table = new map<string, Declaration *>;}
;

declaration
: variable_declaration {$$ = (Declaration *) $1;}
| function_declaration {$$ = (Declaration *) $1;}
;

variable_declaration
: type_specifier ID SEMI{($$ = new Identifier(@2, $1, $2));}
| type_specifier ID bracket_list SEMI{($$ = new Identifier(@2, $1, $2, $3));}
;

bracket_list
: bracket_list OPEN_SQUARE NUM CLOSED_SQUARE {($$ = $1)->push_back(new IntConst(@3, $3));}
| OPEN_SQUARE NUM CLOSED_SQUARE {($$ = new vector<IntConst *>)->push_back(new IntConst(@2, $2));}
;

function_declaration
: type_specifier ID OPEN_BRACKET parameter_list CLOSED_BRACKET statement_block {
	$$ = new FuncDecl(@1, $1, new Identifier(@2, $1, $2), $4, $6);
}
;

statement_block
: OPEN_CURLY variable_declarations statement_list CLOSED_CURLY { $$ = new StatementBlock($2, $3);}
;

variable_declarations
: variable_declarations variable_declaration {($$ = $1); (*$$)[$2->name] = $2;}
| /* EPSILON */ {$$ = new map<string, Identifier *>;}
;

parameter_list 
: parameter_list COMMA type_specifier ID {($$ = $1); (*$$)[*(new string($4))] = (new Identifier(@4, $3, $4));}
| type_specifier ID {($$ = new map<string, Identifier *>); (*$$)[*(new string($2))] = (new Identifier(@2, $1, $2));}
| /* EPSILON */ {$$ = NULL;}
;

type_specifier
: VOID
| CHAR
| INT
| FLOAT
| BOOL
;

statement_list
: statement statement_list {($$ = $2)->push_back($1);}
| /* EPSILON */ {$$ = new vector<Statement *>;}
;
    
statement
: expression_statement {$$ = (Statement *) $1;}
| selection_statement {$$ = (Statement *) $1;}
| iteration_statement {$$ = (Statement *) $1;}
| statement_block {$$ = (Statement *) $1;}
;

primary_expression
: ID { $$ = new Access(@1, *(new string($1))); }
| NUM { $$ = new IntConst(@1, $1); }
| REAL { $$ = new DoubleConst(@1, $1); }
| STRING_LITERAL { $$ = new StringConst(@1, $1); }
| OPEN_BRACKET assignment_expression CLOSED_BRACKET { $$ = $2; }
// TODO:: Add Function Call
// TODO:: Add array access
;

unary_expression
: primary_expression { $$ = $1; }
| unary_operator unary_expression { $$ = new OpExpression($1, $2); }
;

unary_operator
: PLUS %prec UPLUS { $$ = new Operator(@1, PLUS); }
| MINUS %prec UMINUS { $$ = new Operator(@1, MINUS); }
| NOT { $$ = new Operator(@1, NOT); }
| DEC_OP {$$ = new Operator(@1, DEC_OP); }
| INC_OP {$$ = new Operator(@1, INC_OP);}
;

binary_arith_expression
: unary_expression { $$ = $1; }
| binary_arith_expression binary_operator unary_expression { $$ = new OpExpression($2, $1, $3); }
;

binary_operator
: PLUS {$$ = new Operator(@1, PLUS);}
| MINUS {$$ = new Operator(@1, MINUS);}
| STAR {$$ = new Operator(@1, STAR);}
| DIVIDE {$$ = new Operator(@1, DIVIDE);}
// TODO:: Add modulus
;

conditional_expression
: binary_arith_expression { $$ = $1; }
| conditional_expression conditional_operator binary_arith_expression { $$ = new OpExpression($2, $1, $3); }
;

conditional_operator
: LT {$$ = new Operator(@1, LT);}
| GT {$$ = new Operator(@1, GT);}
| AND_OP {$$ = new Operator(@1, AND_OP);}
| OR_OP {$$ = new Operator(@1, OR_OP);}
| EQ_OP {$$ = new Operator(@1, EQ_OP);}
| NE_OP {$$ = new Operator(@1, NE_OP);}
;

assignment_expression
: conditional_expression { $$ = $1; }
| unary_expression ASSIGN assignment_expression { $$ = new OpExpression(new Operator(@2, ASSIGN), $1, $3); }
;

iteration_statement
: WHILE OPEN_BRACKET assignment_expression CLOSED_BRACKET statement { $$ = new IterStatement($3, $5); }
| FOR OPEN_BRACKET expression_statement expression_statement assignment_expression CLOSED_BRACKET statement { $$ = new IterStatement($3, $4, $5, $7); }
;

selection_statement
: IF OPEN_BRACKET assignment_expression CLOSED_BRACKET statement ELSE statement { $$ = new SelStatement($3, $5, $7); }
| IF OPEN_BRACKET assignment_expression CLOSED_BRACKET statement %prec "UIF" { $$ = new SelStatement($3, $5); }
;

expression_statement
: SEMI { $$ = NULL; }
| assignment_expression SEMI { $$ = new ExprStatement; $$->expr = $1; }
;

%%
#include <stdio.h>

extern char yytext[];

int yyerror(char *s){
	fflush(stdout);
	printf("%s\n", s);
}

int main(){
	InitScanner();
  //yydebug = 1;
  return yyparse();
}



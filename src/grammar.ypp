%locations

%code requires {
	#include "errors.h"
	#include "location.h"
	#include "lexer.h"
	#include "ast.h"
	#include <vector>
  #include <map>

	using namespace std;
}

%{
  #include <stdio.h>

  extern int yylex();
  extern int yyerror(char *);
%}

%union{
	int intConst_t;
	bool boolConst_t;
	char *stringConst_t;
	double doubleConst_t;

	IntConst *intConst;
  BoolConst *boolConst;
  StringConst *stringConst;
  DoubleConst *doubleConst;

  char *name;

  enum Type type;

  map<string, Identifier *> *varDecls;
  
  Declaration *decl;
  FuncDecl *funcDecl;
  Identifier *varDecl;
  
  Identifier *id;
  vector<IntConst *> *dimList;

  vector<Statement *> *stmtList;
  Statement *stmt;
  StatementBlock *stmtBlock;
}

%token ELSE FOR IF RETURN WHILE PTR_OP INC_OP DEC_OP AND_OP OR_OP LT GT LE_OP GE_OP EQ_OP NE_OP DO
%token NOT AMP TILDE STAR ASSIGN OPEN_BRACKET CLOSED_BRACKET OPEN_CURLY CLOSED_CURLY OPEN_SQUARE CLOSED_SQUARE
%token SEMI COMMA DOT PLUS MINUS DIVIDE MODULUS PIPE XOR QUES COLON
%token <name> ID
%token <type> BOOL CHAR INT FLOAT VOID
%token <intConst_t> NUM
%token <doubleConst_t> REAL
%token <stringConst_t> STRING_LITERAL
%token <boolConst_t> BOOLEAN

%nonassoc "UIF"
%nonassoc ELSE

%type <decl> declaration
%type <varDecl> variable_declaration
%type <type> type_specifier
%type <dimList> bracket_list

%type <funcDecl> function_declaration
%type <varDecls> parameter_list
%type <varDecls> variable_declarations
%type <stmtBlock> statement_block
%type <stmtList> statement_list
%type <stmt> statement

%%

declaration_list
: declaration_list declaration {(*global_sym_table)[$2->name] = $2;}
| /* EPSILON */ {global_sym_table = new map<string, Declaration *>;}
;

declaration
: variable_declaration {$$ = (Declaration *) $1;}
| function_declaration {$$ = (Declaration *) $1;}
;

variable_declaration
: type_specifier ID SEMI{($$ = new Identifier(@2, $1, $2));}
| type_specifier ID bracket_list SEMI{($$ = new Identifier(@2, $1, $2, $3));}
;

bracket_list
: bracket_list OPEN_SQUARE NUM CLOSED_SQUARE {($$ = $1)->push_back(new IntConst(@3, $3));}
| OPEN_SQUARE NUM CLOSED_SQUARE {($$ = new vector<IntConst *>)->push_back(new IntConst(@2, $2));}
;

function_declaration
: type_specifier ID OPEN_BRACKET parameter_list CLOSED_BRACKET statement_block {
	$$ = new FuncDecl(@1, $1, new Identifier(@2, $1, $2), $4, $6);
}
;

statement_block
: OPEN_CURLY variable_declarations statement_list CLOSED_CURLY { $$ = new StatementBlock($2, $3);}
;

variable_declarations
: variable_declarations variable_declaration {($$ = $1); (*$$)[$2->name] = $2;}
| /* EPSILON */ {$$ = new map<string, Identifier *>;}
;

parameter_list 
: parameter_list COMMA type_specifier ID {($$ = $1); (*$$)[*(new string($4))] = (new Identifier(@4, $3, $4));}
| type_specifier ID {($$ = new map<string, Identifier *>); (*$$)[*(new string($2))] = (new Identifier(@2, $1, $2));}
| /* EPSILON */ {$$ = NULL;}
;

type_specifier
: VOID
| CHAR
| INT
| FLOAT
| BOOL
;

statement_list
: statement statement_list {($$ = $2)->push_back($1);}
| /* EPSILON */ {$$ = new vector<Statement *>;}
;
    
statement
: expression_statement { printf("statement: expression_statement\n\n\n"); }
| selection_statement { printf("statement: selection_statement\n\n\n"); }
| iteration_statement { printf("statement: iteration_statement\n\n\n"); }
| statement_block { printf("statement: OPEN_CURLY statement_list CLOSED_CURLY\n\n\n"); }
;

primary_expression
: ID { printf("primary_expression: ID\n"); }
| NUM { printf("primary_expression: NUM\n"); }
| REAL { printf("primary_expression: REAL\n"); }
| STRING_LITERAL { printf("primary_expression: STRING_LITERAL\n"); }
| OPEN_BRACKET expression CLOSED_BRACKET { printf("primary_expression: OPEN_BRACKET expression CLOSED_BRACKET\n"); }
| OPEN_SQUARE argument_expression_list CLOSED_SQUARE { printf("primary_expression: OPEN_SQUARE argument_expression_list CLOSED_SQUARE\n"); }
;

postfix_expression
: primary_expression { printf("postfix_expression: primary_expression\n"); }
| postfix_expression OPEN_SQUARE expression CLOSED_SQUARE { printf("postfix_expression: postfix_expression OPEN_SQUARE expression CLOSED_SQUARE\n"); }
| postfix_expression OPEN_BRACKET CLOSED_BRACKET { printf("postfix_expression: postfix_expression OPEN_BRACKET CLOSED_BRACKET\n"); }
| postfix_expression OPEN_BRACKET argument_expression_list CLOSED_BRACKET { printf("postfix_expression: postfix_expression OPEN_BRACKET argument_expression_list CLOSED_BRACKET\n"); }
| postfix_expression DOT ID { printf("postfix_expression: postfix_expression DOT ID\n"); }
| postfix_expression PTR_OP ID { printf("postfix_expression: postfix_expression PTR_OP ID\n"); }
| postfix_expression INC_OP { printf("postfix_expression: postfix_expression INC_OP\n"); }
| postfix_expression DEC_OP { printf("postfix_expression: postfix_expression DEC_OP\n"); }
;

argument_expression_list
: assignment_expression  { printf("argument_expression_list: assignment_expression\n"); }
| argument_expression_list COMMA assignment_expression { printf("argument_expression_list: argument_expression_list COMMA assignment_expression\n"); }
;

unary_expression
: postfix_expression { printf("unary_expression: postfix_expression\n"); }
| INC_OP unary_expression { printf("unary_expression: INC_OP unary_expression\n"); }
| DEC_OP unary_expression { printf("unary_expression: DEC_OP unary_expression\n"); }
| unary_operator unary_expression { printf("unary_expression: unary_operator unary_expression\n"); }
;

unary_operator
: AMP { printf("unary_operator: AMP\n"); }
| STAR { printf("unary_operator: STAR\n"); }
| PLUS { printf("unary_operator: PLUS\n"); }
| MINUS { printf("unary_operator: MINUS\n"); }
| TILDE { printf("unary_operator: TILDE\n"); }
| NOT { printf("unary_operator: NOT\n"); }
;

multiplicative_expression
: unary_expression { printf("multiplicative_expression: unary_expression\n"); }
| multiplicative_expression STAR unary_expression { printf("multiplicative_expression: multiplicative_expression STAR unary_expression\n"); }
| multiplicative_expression DIVIDE unary_expression { printf("multiplicative_expression: multiplicative_expression DIVIDE unary_expression\n"); }
| multiplicative_expression MODULUS unary_expression { printf("multiplicative_expression: multiplicative_expression MODULUS unary_expression\n"); }
;

additive_expression
: multiplicative_expression { printf("additive_expression: multiplicative_expression\n"); }
| additive_expression PLUS multiplicative_expression { printf("additive_expression: additive_expression PLUS multiplicative_expression\n"); }
| additive_expression MINUS multiplicative_expression { printf("additive_expression: additive_expression MINUS multiplicative_expression\n"); }
;

relational_expression
: additive_expression { printf("relational_expression: additive_expression\n"); }
| relational_expression LT additive_expression { printf("relational_expression: relational_expression LT additive_expression\n"); }
| relational_expression GT additive_expression { printf("relational_expression: relational_expression GT additive_expression\n"); }
| relational_expression LE_OP additive_expression { printf("relational_expression: relational_expression LE_OP additive_expression\n"); }
| relational_expression GE_OP additive_expression { printf("relational_expression: relational_expression GE_OP additive_expression\n"); }
;

equality_expression
: relational_expression { printf("equality_expression: relational_expression\n"); }
| equality_expression EQ_OP relational_expression { printf("equality_expression: equality_expression EQ_OP relational_expression\n"); }
| equality_expression NE_OP relational_expression { printf("equality_expression: equality_expression EQ_OP relational_expression\n"); }
;

and_expression 
: equality_expression { printf("and_expression: equality_expression\n"); }
| and_expression AMP equality_expression { printf("and_expression: and_expression AMP equality_expression\n"); }
;

exclusive_or_expression
: and_expression { printf("exclusive_or_expression: and_expression\n"); }
| exclusive_or_expression XOR and_expression { printf("exclusive_or_expression: exclusive_or_expression XOR and_expression\n"); }
;

inclusive_or_expression
: exclusive_or_expression { printf("inclusive_or_expression: exclusive_or_expression\n"); }
| inclusive_or_expression PIPE exclusive_or_expression { printf("inclusive_or_expression: inclusive_or_expression PIPE exclusive_or_expression\n"); }
;

logical_and_expression
: inclusive_or_expression { printf("logical_and_expression: inclusive_or_expression\n"); }
| logical_and_expression AND_OP inclusive_or_expression { printf("logical_and_expression: logical_and_expression AND_OP inclusive_or_expression\n"); }
;

logical_or_expression
: logical_and_expression { printf("logical_or_expression: logical_and_expression\n"); }
| logical_or_expression OR_OP logical_and_expression { printf("logical_or_expression: logical_or_expression OR_OP logical_and_expression\n"); }
;

conditional_expression
: logical_or_expression { printf("conditional_expression: logical_or_expression\n"); }
| logical_or_expression QUES expression COLON conditional_expression { printf("conditional_expression: logical_or_expression QUES expression COLON conditional_expressionn"); }
;

assignment_expression
: conditional_expression { printf("assignment_expression: conditional_expression\n\n"); }
| unary_expression ASSIGN assignment_expression { printf("assignment_expression: unary_expression ASSIGN assignment_expression\n\n"); }
;

expression
: assignment_expression { printf("expression: assignement_expression\n"); }
| expression COMMA assignment_expression { printf("expression: expression COMMA assignment_expression\n"); }
;

iteration_statement
: WHILE OPEN_BRACKET expression CLOSED_BRACKET statement { printf("iteration_statement: WHILE OPEN_BRACKET expression CLOSED_BRACKET statement\n"); }
| DO statement WHILE OPEN_BRACKET expression CLOSED_BRACKET SEMI { printf("iteration_statement: DO statement WHILE OPEN_BRACKET expression CLOSED_BRACKET SEMI\n"); }
| FOR OPEN_BRACKET expression_statement expression_statement CLOSED_BRACKET statement { printf("iteration_statement: FOR OPEN_BRACKET expression_statement expression_statement CLOSED_BRACKET statement\n"); }
| FOR OPEN_BRACKET expression_statement expression_statement expression CLOSED_BRACKET statement { printf("iteration_statement: FOR OPEN_BRACKET expression_statement expression_statement expression CLOSED_BRACKET statement\n"); }
| FOR OPEN_BRACKET declaration expression_statement CLOSED_BRACKET statement { printf("iteration_statement: FOR OPEN_BRACKET declaration expression_statement CLOSED_BRACKET statement\n"); }
| FOR OPEN_BRACKET declaration expression_statement expression CLOSED_BRACKET statement { printf("iteration_statement: FOR OPEN_BRACKET declaration expression_statement expression CLOSED_BRACKET statement\n"); }
;

selection_statement
: IF OPEN_BRACKET expression CLOSED_BRACKET statement ELSE statement { printf("selection_statement: IF OPEN_BRACKET expression CLOSED_BRACKET statement ELSE statement\n"); }
| IF OPEN_BRACKET expression CLOSED_BRACKET statement %prec "UIF" { printf("IF OPEN_BRACKET expression CLOSED_BRACKET statement\n"); }
;

expression_statement
: SEMI { printf("expression_statement: SEMI\n"); }
| expression SEMI { printf("expression_statement: expression SEMI\n"); }
;

%%
#include <stdio.h>

extern char yytext[];

int yyerror(char *s){
	fflush(stdout);
	printf("%s\n", s);
}

int main(){
	InitScanner();
  //yydebug = 1;
  return yyparse();
}


